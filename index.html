<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MediaPipe Motion Analysis</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sockjs-client@1.6.1/dist/sockjs.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
            font-family: monospace;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* 거울 효과 */
        }
        
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        #status {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 10;
        }
        
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10;
        }
        
        button {
            background: rgba(0,0,0,0.8);
            color: white;
            border: none;
            padding: 8px 12px;
            margin: 2px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        
        button:hover {
            background: rgba(0,0,0,0.9);
        }
        
        button.active {
            background: #4CAF50;
        }
    </style>
</head>
<body>
    <div id="container">
        <video id="video" autoplay muted playsinline></video>
        <canvas id="canvas"></canvas>
        
        <div id="status">
            <div>FaceMesh: <span id="facemesh-status">초기화 중...</span></div>
            <div>얼굴: <span id="face-count">0</span></div>
            <div>프레임: <span id="frame-count">0</span></div>
            <div>유효 데이터: <span id="valid-count">0</span></div>
            <div>WebSocket: <span id="ws-status">연결 안됨</span></div>
            <div>큐 크기: <span id="queue-size">0</span></div>
        </div>
        
        <div id="controls">
            <button id="start-btn" onclick="startCapture()">시작</button>
            <button id="stop-btn" onclick="stopCapture()">중지</button>
        </div>
    </div>

    <script>
        // ===== 전역 변수 =====
        const STUDY_BASE = 'https://i13c201.p.ssafy.io/study';
        
        // 랜드마크 인덱스 (Python 코드와 동일)
        const STANDARD_FACE_LANDMARKS = [
            33, 133, 159, 145, 158, 153,      // Right Eye (6)
            263, 362, 386, 374, 385, 380      // Left Eye  (6)
        ];
        const MOUTH_LANDMARKS = [78, 308, 13, 14];          // 4
        const HEAD_POSE_LANDMARKS = [1, 152, 10, 33, 263];  // 5
        
        const COLLECTION_INTERVAL_MS = 1000;   // 좌표 수집 throttle
        const BATCH_FLUSH_MS = 10000;          // 배치 전송 주기
        
        // 상태 변수
        let video, canvas, ctx;
        let faceMesh;
        let camera;
        let isActive = false;
        let frameCount = 0;
        let validDataCount = 0;
        let faceCount = 0;
        let lastEnqueueTime = 0;
        
        // WebSocket 관련
        let socket = null;
        let isConnected = false;
        let isSubscribed = false;
        let wsStatus = 'disconnected';
        
        // 배치 큐
        let motionQueue = [];
        let batchTimer = null;
        
        // URL 파라미터에서 값 추출
        const urlParams = new URLSearchParams(window.location.search);
        const studyRoomId = urlParams.get('studyRoomId') || '24';
        const myUserId = urlParams.get('myUserId') || '12';
        const accessToken = urlParams.get('accessToken') || '';
        
        // ===== 초기화 =====
        window.onload = function() {
            video = document.getElementById('video');
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            
            updateStatus('facemesh-status', '초기화 중...');
            initializeFaceMesh();
        };
        
        // ===== MediaPipe FaceMesh 초기화 =====
        function initializeFaceMesh() {
            faceMesh = new FaceMesh({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
                }
            });
            
            faceMesh.setOptions({
                maxNumFaces: 1,
                refineLandmarks: true,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            
            faceMesh.onResults(onFaceMeshResults);
            updateStatus('facemesh-status', '완료');
        }
        
        // ===== FaceMesh 결과 처리 =====
        function onFaceMeshResults(results) {
            frameCount++;
            updateStatus('frame-count', frameCount);
            
            // 캔버스 크기 조정
            canvas.width = results.image.width;
            canvas.height = results.image.height;
            
            // 배경 이미지 그리기 (거울 효과)
            ctx.save();
            ctx.scale(-1, 1);
            ctx.drawImage(results.image, -canvas.width, 0, canvas.width, canvas.height);
            ctx.restore();
            
            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                faceCount = results.multiFaceLandmarks.length;
                updateStatus('face-count', faceCount);
                
                const landmarks = results.multiFaceLandmarks[0];
                
                // 좌표 추출
                const eyeLandmarks = extractLandmarks(landmarks, STANDARD_FACE_LANDMARKS);
                const mouthLandmarks = extractLandmarks(landmarks, MOUTH_LANDMARKS);
                const headPoseLandmarks = extractLandmarks(landmarks, HEAD_POSE_LANDMARKS);
                
                const valid = (eyeLandmarks.length === 12 && mouthLandmarks.length === 4 && headPoseLandmarks.length === 5);
                
                if (valid) {
                    validDataCount++;
                    updateStatus('valid-count', validDataCount);
                    
                    const now = Date.now();
                    if (now - lastEnqueueTime >= COLLECTION_INTERVAL_MS) {
                        lastEnqueueTime = now;
                        
                        const motionData = {
                            studyRoomId: parseInt(studyRoomId),
                            eyeLandmarks: eyeLandmarks,
                            mouthLandmarks: mouthLandmarks,
                            headPoseLandmarks: headPoseLandmarks
                        };
                        
                        motionQueue.push(motionData);
                        updateStatus('queue-size', motionQueue.length);
                        
                        console.log('FaceMesh 좌표 수집:', {
                            눈_좌표: eyeLandmarks.length,
                            입_좌표: mouthLandmarks.length,
                            머리_좌표: headPoseLandmarks.length,
                            유효성: valid
                        });
                    }
                }
                
                // 랜드마크 그리기 (선택사항)
                drawLandmarks(landmarks);
            } else {
                faceCount = 0;
                updateStatus('face-count', faceCount);
            }
        }
        
        // ===== 랜드마크 추출 =====
        function extractLandmarks(allLandmarks, indices) {
            return indices.map(i => {
                const point = allLandmarks[i];
                if (point && typeof point.x === 'number' && typeof point.y === 'number') {
                    return [round4(point.x), round4(point.y)];
                }
                return null;
            }).filter(Boolean);
        }
        
        // ===== 랜드마크 그리기 =====
        function drawLandmarks(landmarks) {
            ctx.fillStyle = 'red';
            landmarks.forEach((landmark) => {
                const x = (1 - landmark.x) * canvas.width; // 거울 효과 적용
                const y = landmark.y * canvas.height;
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, 2 * Math.PI);
                ctx.fill();
            });
        }
        
        // ===== 카메라 시작 =====
        async function startCapture() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        facingMode: 'user',
                        width: { ideal: 640 },
                        height: { ideal: 480 }
                    }
                });
                
                video.srcObject = stream;
                
                camera = new Camera(video, {
                    onFrame: async () => {
                        if (isActive) {
                            await faceMesh.send({ image: video });
                        }
                    },
                    width: 640,
                    height: 480
                });
                
                isActive = true;
                camera.start();
                
                // WebSocket 연결
                connectWebSocket();
                
                // 배치 타이머 시작
                if (!batchTimer) {
                    batchTimer = setInterval(flushBatch, BATCH_FLUSH_MS);
                }
                
                // 세션 시작
                startMotionSession();
                
                document.getElementById('start-btn').classList.add('active');
                document.getElementById('stop-btn').classList.remove('active');
                
            } catch (err) {
                console.error('카메라 시작 실패:', err);
                alert('카메라 접근 권한이 필요합니다.');
            }
        }
        
        // ===== 카메라 중지 =====
        function stopCapture() {
            isActive = false;
            
            if (camera) {
                camera.stop();
            }
            
            if (video.srcObject) {
                video.srcObject.getTracks().forEach(track => track.stop());
                video.srcObject = null;
            }
            
            if (socket) {
                socket.close();
                socket = null;
            }
            
            if (batchTimer) {
                clearInterval(batchTimer);
                batchTimer = null;
            }
            
            document.getElementById('start-btn').classList.remove('active');
            document.getElementById('stop-btn').classList.add('active');
            
            updateStatus('ws-status', '연결 안됨');
        }
        
        // ===== WebSocket 연결 =====
        function connectWebSocket() {
            if (!accessToken || !studyRoomId) {
                console.warn('토큰 또는 스터디룸 ID가 없습니다.');
                return;
            }
            
            if (socket) {
                socket.close();
                socket = null;
            }
            
            try {
                const sockUrl = `${STUDY_BASE}/ws-stomp?token=${encodeURIComponent(accessToken)}`;
                updateStatus('ws-status', '연결 중...');
                
                socket = new SockJS(sockUrl);
                
                socket.onopen = function() {
                    const connectFrame = 
                        `CONNECT\n` +
                        `accept-version:1.0,1.1,2.0\n` +
                        `heart-beat:10000,10000\n` +
                        `\n\u0000`;
                    socket.send(connectFrame);
                };
                
                socket.onmessage = function(event) {
                    const data = String(event.data || '');
                    if (!data.trim()) return;
                    
                    if (data.startsWith('CONNECTED')) {
                        isConnected = true;
                        updateStatus('ws-status', '연결됨');
                        
                        // 모션 채널 구독
                        const motionSubFrame = 
                            `SUBSCRIBE\n` +
                            `id:motion-sub-${studyRoomId}\n` +
                            `destination:/sub/motion/study/${studyRoomId}\n` +
                            `\n\u0000`;
                        socket.send(motionSubFrame);
                        
                        isSubscribed = true;
                        updateStatus('ws-status', '구독완료');
                        return;
                    }
                    
                    if (data.startsWith('MESSAGE')) {
                        const body = extractStompBody(data);
                        if (!body) return;
                        
                        try {
                            const payload = JSON.parse(body);
                            
                            // 모션 데이터 처리
                            if (data.includes(`/sub/motion/study/${studyRoomId}`)) {
                                console.log('모션 상태 수신:', payload);
                                
                                // React Native로 메시지 전송 (WebView에서 부모로)
                                if (window.ReactNativeWebView) {
                                    window.ReactNativeWebView.postMessage(JSON.stringify({
                                        type: 'motion_update',
                                        data: payload
                                    }));
                                }
                            }
                        } catch (e) {
                            console.error('JSON 파싱 실패:', e);
                        }
                        return;
                    }
                    
                    if (data.startsWith('ERROR')) {
                        isConnected = false;
                        isSubscribed = false;
                        updateStatus('ws-status', '에러');
                        tryReconnect();
                        return;
                    }
                };
                
                socket.onerror = function(err) {
                    console.error('WebSocket 에러:', err);
                    updateStatus('ws-status', '에러');
                };
                
                socket.onclose = function(event) {
                    isConnected = false;
                    isSubscribed = false;
                    updateStatus('ws-status', '연결 끊김');
                    socket = null;
                    tryReconnect();
                };
                
            } catch (e) {
                console.error('WebSocket 연결 실패:', e);
                socket = null;
                tryReconnect();
            }
        }
        
        // ===== 재연결 시도 =====
        function tryReconnect() {
            setTimeout(() => {
                if (!isConnected && isActive) {
                    connectWebSocket();
                }
            }, 2000);
        }
        
        // ===== 배치 전송 =====
        function flushBatch() {
            try {
                if (!socket || !isConnected || motionQueue.length === 0) {
                    return;
                }
                
                const batchMessage = {
                    studyRoomId: parseInt(studyRoomId),
                    batchTimestamp: new Date().toISOString(),
                    dataPoints: motionQueue.splice(0, motionQueue.length)
                };
                
                const frame = 
                    `SEND\n` +
                    `destination:/pub/motion/batch\n` +
                    `content-type:application/json\n` +
                    `\n` +
                    `${JSON.stringify(batchMessage)}\u0000`;
                
                socket.send(frame);
                updateStatus('queue-size', motionQueue.length);
                
                console.log('배치 전송:', {
                    스터디룸: studyRoomId,
                    데이터_개수: batchMessage.dataPoints.length
                });
                
            } catch (e) {
                console.error('배치 전송 실패:', e);
            }
        }
        
        // ===== 세션 시작 =====
        async function startMotionSession() {
            try {
                const url = `${STUDY_BASE}/test/activity/session/start/${studyRoomId}/${myUserId}`;
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        ...(accessToken ? { Authorization: `Bearer ${accessToken}` } : {})
                    }
                });
                
                console.log('세션 시작:', response.ok ? '성공' : '실패');
            } catch (e) {
                console.error('세션 시작 실패:', e);
            }
        }
        
        // ===== React Native에서 메시지 수신 =====
        window.addEventListener('message', function(event) {
            try {
                const data = JSON.parse(event.data);
                
                if (data.action === 'start_tracking') {
                    startCapture();
                } else if (data.action === 'stop_tracking') {
                    stopCapture();
                }
            } catch (e) {
                console.error('메시지 처리 실패:', e);
            }
        });
        
        // ===== 유틸리티 함수 =====
        function round4(v) {
            return Math.round((v + Number.EPSILON) * 10000) / 10000;
        }
        
        function extractStompBody(data) {
            const sep = '\n\n';
            const i = data.indexOf(sep);
            if (i === -1) return '';
            let body = data.slice(i + sep.length);
            if (body.endsWith('\u0000')) body = body.slice(0, -1);
            return body;
        }
        
        function updateStatus(elementId, value) {
            const element = document.getElementById(elementId);
            if (element) {
                element.textContent = value;
            }
        }
        
        // ===== 페이지 언로드 시 정리 =====
        window.addEventListener('beforeunload', function() {
            stopCapture();
        });
    </script>
</body>
</html>